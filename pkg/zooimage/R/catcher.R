## Copyright (c) 2009-2012, Ph. Grosjean <phgrosjean@sciviews.org>
##
## This file is part of ZooImage
## 
## ZooImage is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 of the License, or
## (at your option) any later version.
## 
## ZooImage is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with ZooImage.  If not, see <http://www.gnu.org/licenses/>.

## catchers : the idea here is to separate the main job of the 
##            function from the job of handling errors 
##            generated by other functions it is calling
## Each function that wants to make use of this system must do two 
## things: 
## 
## - At the beginning of the function, add these lines of code, which 
##   will have the effect of recalling the function with the 
##   appropriate catcher if a catcher is not already active. If there 
##   already is an active catcher, then the function simply continues
##   to execute as normal
##
##   if (is.null(getCatcher())) return(catch(match.call())) 
##
## - The function must have a "catcher" attribute which is a catcher : 
##   a function taking a "call" argument, and which evaluates it with 
##   the appropriate calling handlers. If the function does not 
##   have a catcher attribute, then the dummyCatcher is used so that 
##   the call is evaluated verbatim

## An environment where the current catcher is stored
catch.env <- new.env()

## Get the current call stack
callStack <- function ()
{
	calls <- sys.calls()
	out <- lapply(calls, function(.) {
		out <- try( as.character(.[[1]] ), silent = TRUE)
		if (inherits(out, "try-error")) NULL else out
	})
	out <- unlist(out[!sapply(out, is.null)])
	return(out)
}

## Evaluates the call calling the catcher associated with the function calling
##
## call: the call to surround with the catcher
## debug: logical, if TRUE prints debugging information
recallWithCatcher <- function (call, debug = FALSE)
{	
	catcher <- getCatcher()
	on.exit(resetCatcher())
	
	if (is.null(catcher)) {
		warning("no catcher available") 
		catcher <- dummyCatcher
	} 
	
	if (debug) print(callStack())
	
	logClear()
	res <- catcher(call)
	if ("show.log" %in% names(call) && call[["show.log"]])
		logView() 
	return(res)
}

## Get the current catcher
getCatcher <- function ()
	catch.env[["catcher"]] 

## Set the current catcher
setCatcher <- function (catcher)
	if (!is.null(catcher)) catch.env[["catcher"]] <- catcher

## A catcher that does nothing more than evaluating the call
dummyCatcher <- function (call)
	eval(call) 

## Set the catcher to NULL
resetCatcher <- function ()
	catch.env[["catcher"]] <- NULL

## Finds the main catcher associated with the function making the call,
## and recall the call with the catcher
catch <- function (call)
{
	## Find the name of the function which want to catch
	fun <- match.fun(as.character(call[[1]]))
	
	if (is.null(getCatcher())) {
		## See if it has a catcher
		catcher <- attr(fun, "catcher")
		if (is.null(catcher))
			base::stop(sprintf( "'%s' does not have a catcher",
				as.character(call[[1]])))
		setCatcher(catcher) 
		recallWithCatcher(call)
	}
}
