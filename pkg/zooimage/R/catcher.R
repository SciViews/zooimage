# Copyright (c) 2009, Ph. Grosjean <phgrosjean@sciviews.org>
#
# This file is part of ZooImage .
# 
# ZooImage is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
# 
# ZooImage is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with ZooImage.  If not, see <http://www.gnu.org/licenses/>.




# catchers : the idea here is to separate the main job of the 
#            function from the job of handling errors 
#            generated by other functions it is calling
# each function that wants to make use of this system must do two 
# things: 
# 
# - at the beginning of the function, add these lines of code, which 
#   will have the effect of recalling the function with the 
#   appropriate catcher if a catcher is not already active. If there 
#   already is an active catcher, then the function simply continues
#   to execute as normal
#
#   if( is.null( getCatcher() ) ){
#		return( catch(match.call()) ) 
#	}
#
# - the function must have a "catcher" attribute which is a catcher : 
#   a function taking a "call" argument, and which evaluates it with 
#   the appropriate calling handlers. If the function does not 
#   have a catcher attribute, then the dummyCatcher is used so that 
#   the call is evaluated verbatim


# {{{ an environment where the current catcher is stored
catch.env <- new.env()
# }}}

# {{{ recallWithCatcher
#' Evaluates the call calling the catcher associated with the 
#' function calling
#'
#' @param call the call to surround with the catcher
#' @param debug logical, if T prints debugging information
recallWithCatcher <- function( call, debug = FALSE ){
	
	catcher <- getCatcher( )
	on.exit( resetCatcher() )
	
	if( is.null( catcher ) ){
		warning( "no catcher available" ) 
		catcher <- dummyCatcher
	} 
	
	if( debug ){
		print( callStack() )
	}
	
	logClear()
	res <- catcher( call )
	if( "show.log" %in% names(call) && call[["show.log"]] ){
		logView() 
	}
	res
}
# }}}

# {{{ getCatcher
#' gets the current catcher
getCatcher <- function( ){
	catch.env[["catcher"]] 
}
# }}}

# {{{ setCatcher
#' sets the current catcher
setCatcher <- function( catcher ){
	if( !is.null(catcher) ) {
		catch.env[["catcher"]] <- catcher
	}
}
# }}}

# {{{ dummyCatcher
#' a catcher that does nothing more than evaluating the call
dummyCatcher <- function( call ){
	eval( call ) 
}
# }}}

# {{{ set the catcher to NULL
resetCatcher <- function( ){
	catch.env[["catcher"]] <- NULL
}
# }}}

# {{{ catch
#' finds the main catcher associated with the function
#' making the call, and recall the call with the 
#' catcher
catch <- function( call ){
	# find the name of the function which want to catch
	fun <- match.fun( as.character(call[[1]]) )
	
	if( is.null( getCatcher() ) ){
		# see if it has a catcher
		catcher <- attr( fun, "catcher" )
		setCatcher( catcher ) 
	}
	
	recallWithCatcher( call )
	
}
# }}}

# :tabSize=4:indentSize=4:noTabs=false:folding=explicit:collapseFolds=1:
